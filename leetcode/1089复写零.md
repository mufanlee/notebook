# [1089. 复写零](https://leetcode.cn/problems/duplicate-zeros/)

### 题目

给你一个长度固定的整数数组 `arr`，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。

要求：请对输入的数组 **就地** 进行上述修改，不要从函数返回任何东西。

 

**示例 1：**

```
输入：[1,0,2,3,0,4,5,0]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
```

**示例 2：**

```
输入：[1,2,3]
输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]
```

 

**提示：**

1. `1 <= arr.length <= 10000`
2. `0 <= arr[i] <= 9`

### 解题思路

#### 方法：双指针

- 定义两个指针 $i$ 和 $j$，$i$ 指向复写零的数组，$j$ 指向没有复写的数组 $arr$，碰到零时，指针 $i$ 移动 $2$，否则移动 $1$。

- 遍历数组 $arr$，当 $i$ 指向的位置超过数组 $arr$ 时结束，此时 $j$ 指向的位置为复写零后能保留的元素的最大位置。
- 由于 $i$ 是大于 $arr$ 长度时结束遍历的，因此，$i$ 和 $j$ 都要向前移动一个位置。
- 从 $i$ 和 $j$ 指向的位置往前遍历 $arr$，遍历过程中修改 $arr$ 为复写后的值。

##### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

### 代码

```java
class Solution {
    public void duplicateZeros(int[] arr) {
        int i = 0, j = 0, n = arr.length;
        for (; i < n; i++, j++) {
            if (arr[j] == 0) {
                i++;
            }
        }
        j--;
        i--;
        while (j >= 0) {
            if (i < n)
                arr[i] = arr[j];
            if (arr[j] == 0) {
                i--;
                arr[i] = 0;
            }
            i--;
            j--;
        }
    }
}
```

