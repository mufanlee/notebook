# [874. 模拟行走机器人](https://leetcode.cn/problems/walking-robot-simulation/)

### 题目

机器人在一个无限大小的 XY 网格平面上行走，从点 `(0, 0)` 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 `commands` ：

- `-2` ：向左转 `90` 度
- `-1` ：向右转 `90` 度
- `1 <= x <= 9` ：向前移动 `x` 个单位长度

在网格上有一些格子被视为障碍物 `obstacles` 。第 `i` 个障碍物位于网格点  `obstacles[i] = (xi, yi)` 。

机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。

返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 `5` ，则返回 `25` ）

 

**注意：**

- 北表示 `+Y` 方向。
- 东表示 `+X` 方向。
- 南表示 `-Y` 方向。
- 西表示 `-X` 方向。

 

**示例 1：**

```
输入：commands = [4,-1,3], obstacles = []
输出：25
解释：
机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 3 个单位，到达 (3, 4)
距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25
```

**示例 2：**

```
输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出：65
解释：机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)
4. 左转
5. 向北走 4 个单位，到达 (1, 8)
距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65
```

 

**提示：**

- `1 <= commands.length <= 10^4`
- `commands[i]` is one of the values in the list `[-2,-1,1,2,3,4,5,6,7,8,9]`.
- `0 <= obstacles.length <= 10^4`
- `-3 * 104 <= xi, yi <= 3 * 10^4`
- 答案保证小于 `2^31`

### 解题思路

#### 方法：模拟

直接模拟机器人行走：

- 用 $0$、$1$、$2$、$3$ 分别表示 $y$ 轴正方向、$x$ 轴正方向、$y$ 轴负方向、$x$ 轴负方向。

- 向左转 `90` 度，则下一个方向为 $(d+3)\%4$，向右转 `90` 度，则下一个方向为 $(d+1)\%4$。
- 注意移动时，机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上。
- 对于移动的位置是否是障碍物，我们可以使用 $set$ 进行判断，其中每个点可以进行编码以便于存入 $set$：$((x+30000)<<16)+(y+30000)$。

##### 复杂度分析

- 时间复杂度：$O(m+n)$，其中 $m$ 和 $n$ 分别是 $commands$ 和 $obstacles$ 的长度。
- 空间复杂度：$O(n)$。

### 代码

```java
class Solution {
    public int robotSim(int[] commands, int[][] obstacles) {
        int[] dx = new int[]{0, 1, 0, -1};
        int[] dy = new int[]{1, 0, -1, 0};
        Set<Long> set = new HashSet<>();
        for (int[] ob : obstacles) {
            set.add((((long) ob[0] + 30000) << 16) + ((long) ob[1] + 30000));
        }

        int ans = 0;
        int x = 0, y = 0, d = 0;
        for (int cmd : commands) {
            if (cmd == -2) {
                d = (d + 3) % 4;
            } else if (cmd == -1) {
                d = (d + 1) % 4;
            } else {
                for (; cmd > 0; cmd--) {
                    int nx = x + dx[d];
                    int ny = y + dy[d];
                    long code = (((long) nx + 30000) << 16) + ((long) ny + 30000);
                    if (!set.contains(code)) {
                        x = nx;
                        y = ny;
                        ans = Math.max(ans, x * x + y * y);
                    }
                }
            }
        }
        return ans;
    }
}
```

