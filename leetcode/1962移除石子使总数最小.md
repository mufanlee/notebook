# 5839. 移除石子使总数最小

### 题目（中等）

给你一个整数数组 `piles` ，数组 **下标从 `0` 开始 **，其中 `piles[i]` 表示第 `i` 堆石子中的石子数量。另给你一个整数 `k` ，请你执行下述操作 **恰好 k 次**：

- 选出任一石子堆 `piles[i]` ，并从中 **移除** `floor(piles[i] / 2)` 颗石子。

**注意**：你可以对 **同一堆** 石子多次执行此操作。

返回执行 `k` 次操作后，剩下石子的 **最小** 总数。

`floor(x)` 为 **小于** 或 **等于** `x` 的 最大 整数。（即，对 `x` 向下取整）。

示例 1：

> 输入：piles = [5,4,9], k = 2
> 输出：12
> 解释：可能的执行情景如下：
> - 对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,5] 。
> - 对第 0 堆石子执行移除操作，石子分布情况变成 [3,4,5] 。
  剩下石子的总数为 12 。

示例 2：

> 输入：piles = [4,3,6,7], k = 3
> 输出：12
> 解释：可能的执行情景如下：
> - 对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,3,7] 。
> - 对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,4] 。
> - 对第 0 堆石子执行移除操作，石子分布情况变成 [2,3,3,4] 。
> 剩下石子的总数为 12 。


提示：

`1 <= piles.length <= 10^5`
`1 <= piles[i] <= 10^4`
`1 <= k <= 10^5`

### 解题思路

#### 方法一：优先队列（最大堆）

为了使得操作后剩下的石头最小，我们需要在每次操作时尽可能多地移除石子，即选择石子数量**最多**的一堆进行操作。

我们可以用一个最大堆实现的优先队列来维护石子堆数组`piles`，它可以在 $$O(logn)$$ 的时间复杂度下实现「查询并移除最大值」与「插入元素」这两个操作。

每一次操作时，我们首先记录并弹出 `piles` 中的最大值 `tmp`，随后从中减去 $$\lfloor \textit{tmp} / 2 \rfloor$$（其中 $$\lfloor \dots \rfloor$$​代表向下取整），并将修改后的值添加进 `piles` 中。当进行 `k` 次操作后，我们计算 `piles` 中各元素之和，并返回作为答案。

##### 复杂度分析

- 时间复杂度：$$O(n + klog(n))$$​
- 空间复杂度：$$O(n)$$

### 代码

```java
class Solution {
    public int minStoneSum(int[] piles, int k) {
        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());
        int sum = 0;
        for (int p : piles) {
            queue.offer(p);
            sum += p;
        }

        int remove = 0;
        for (int i = 0; i < k; i++) {
            Integer pile = queue.remove();
            if (pile == 1) {
                break;
            }

            remove += pile / 2;
            queue.offer(pile - pile / 2);
        }
        return sum - remove;
    }
}
```

