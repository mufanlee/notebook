# 子掩码枚举

### 枚举给定掩码的所有子掩码

给定一个掩码 $$m$$，你想高效地迭代出它的所有子掩码，即只包含掩码 $$m$$ 中二进制位为 $$1$$ 的掩码 $$s$$。

考虑此算法的实现，基于位操作的技巧：

```java
int s = m;
while (s > 0) {
    // ... you can use s...
    s = (s - 1) & m;
}
```

 或者，使用更紧凑的语句 `for`：

```java
for (int s = m; s > 0; s = (s - 1) & m) {
    // ... you can use s...
}
```

在上述两种代码中，将不处理等于 $$0$$ 的子掩码。我们也可以在循环之外处理它，使用不太优雅的设计，例如：

```java
for (int s = m; ; s = (s - 1) & m) {
    // ... you can use s...
    if (s == 0) break;
}
```

让我们来看看为什么上述代码遍历了掩码 $$m$$ 的所有子掩码，没有重复，并且按下降顺序遍历。

假设我们当前为掩码 $$s$$，并想遍历下一个掩码。通过将 $$s$$ 减去 $$1$$，我们将移除 $$s$$ 二进制位中最右边的 $$1$$，并且从该位往右都为 $$1$$。然后我们移除所有的不包含在掩码 $$m$$ 中的不能成为其一部分的“额外的”值为 $$1$$ 的位。为了实现这种移除，我们使用位运算 $$(s - 1) \& m$$。最终，我们将掩码“剪掉” $$1$$ 来得到它所能得到的最大值，因此 $$s$$ 的下一个掩码是递减的。

因此，这个算法生成的掩码的所有子掩码是递减的，并且每个迭代只有两个为操作。

一个特例是 $$s = 0$$。在执行 $$s - 1$$ 后，我们得到一个所有位都为 $$1$$ 的掩码（-1），并且在执行 $$(s - 1) \& m$$ 后，我们的、得到的 $$s$$ 将等于 $$m$$。因此，当 $$s = 0$$ 时需要小心，如果循环不能以 $$0$$ 结束，这个算法将进入无限循环中。

### 遍历所有掩码的子掩码 $$O(3^n)$$

在许多问题中，尤其是使用位掩码的动态规划中，你想迭代所有的位掩码，即每个掩码的的所有子掩码：

```java
for (int m = 0; m < (1 << n); ++m) {
    for (int s = m; s > 0; (s - 1) & m) {
        // ... s and m ...
    }
}
```

