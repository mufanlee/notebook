{"./":{"url":"./","title":"简介","keywords":"","body":"notebook/notebook my notebook Getting Started Download links: SSH clone URL: ssh://git@git.jetbrains.space/lipeng/notebook/notebook.git HTTPS clone URL: https://git.jetbrains.space/lipeng/notebook/notebook.git These instructions will get you a copy of the project up and running on your local machine for development and testing purposes. Prerequisites What things you need to install the software and how to install them. Examples Deployment Add additional notes about how to deploy this on a production system. Resources Add links to external resources for this project, such as CI server, bug tracker, etc. powered by Gitbook该文件修订时间： 2021-04-10 13:03:55 "},"algorithms/":{"url":"algorithms/","title":"算法","keywords":"","body":"算法 powered by Gitbook该文件修订时间： 2021-03-13 08:54:33 "},"algorithms/binary-search/二分查找.html":{"url":"algorithms/binary-search/二分查找.html","title":"二分查找","keywords":"","body":"二分查找 powered by Gitbook该文件修订时间： 2021-04-07 20:11:01 "},"algorithms/segment-tree/线段树.html":{"url":"algorithms/segment-tree/线段树.html","title":"线段树","keywords":"","body":"线段树/区间树（Segment Tree） 介绍 区间树能够对保存的数据进行适当的预处理，以快速回复查询。 区间树常用于在一维数组的特定区间对查询进行快速回复。 区间树的最简单的应用就是求区间最小值问题。 区间树的基本思路： 生成表示给定数组各区间的二叉树，此时区间树的根节点总是表示整个区间 [0, n - 1]，而一个树结构的左侧后代节点和右侧后代节点分别表示该区间的左半侧和右半侧，区间树的叶节点表示长度为 1 的区间。 经过这种预处理后，给出某个区间 [i, j] 时，就可以利用包含在区间树节点中的区间集合表示此区间。 区间树的表示方法 区间树为几乎被“填满”的二叉树，这种二叉树使用数组表示更能节省内存空间，节点 i 的左右后代节点分别为 2 * i 和 2 * i + 1。 那么此数组的长度为多少呢？设元素个数为 n，如果 n 是2 的幂，如 2k−12^{k-1}2​k−1​​，则区间树总结点数为 2k−12^k-12​k​​−1，则数组长度为 2n 即可，否则就需要取大于等于 n 的 2 的幂后再乘以 2。也可以直接将 n 乘以 4，虽然此方法会浪费一些内存。 初始化区间树 struct RMQ { int n; vector rangeMin; RMQ(const vector& array) { n = array.size(); rangeMin.resize(n * 4); init(array, 0, n - 1, 1); } int init(const vector& array, int left, int right, int node) { if (left == right) { return rangeMin[node] = array[left]; } int mid = (left + mid) / 2; int leftMin = init(array, left, mid, node * 2); int rightMin = init(array, mid + 1, right, node * 2 + 1); return rangeMin[node] = min(leftMin, rightMin); } }; 时间复杂度：O(n)O(n)O(n) 区间树的查询处理 const int INT_MAX = numeric_limits::max(); struct RMQ { int query(int left, int right, int node, int nodeLeft, int nodeRight) { if (right nodeRight) return INT_MAX; if (left 时间复杂度：log(n)log(n)log(n) 更新区间树 struct RMQ { int update(int index, int newValue, int node, int nodeLeft, int nodeRight) { if (index nodeRight) return rangeMin[node]; if (nodeLeft == nodeRight) return rangeMin[node] = newValue; int mid = (nodeLeft + nodeRight) / 2; return rangeMin[node] = min(update(index, newValue, node * 2, nodeLeft, mid), update(index, newValue, node * 2 + 1, mid + 1, nodeRight)); } int update(int index, int newValue) { return update(index, newValue, 1, 0, n - 1); } }; 时间复杂度：log(n)log(n)log(n) powered by Gitbook该文件修订时间： 2021-04-07 21:47:12 "},"algorithms/binary-indexed-tree/树状数组.html":{"url":"algorithms/binary-indexed-tree/树状数组.html","title":"树状数组","keywords":"","body":"树状数组 powered by Gitbook该文件修订时间： 2021-04-07 20:11:01 "},"algorithms/bit/位运算.html":{"url":"algorithms/bit/位运算.html","title":"位运算","keywords":"","body":"位运算 lowbit()函数 保留 x 二进制的最后一位（能整除 x 的最大的 2n2^n2​n​​）： x - (x & (x - 1)) x & ~(x - 1) x & -x 原理：二进制补码 将 x 二进制的最后一位变为0： x & (x - 1) powered by Gitbook该文件修订时间： 2021-03-21 11:56:30 "},"cp-algorithms/":{"url":"cp-algorithms/","title":"CP-Algorithms","keywords":"","body":"CP-Algorithms powered by Gitbook该文件修订时间： 2021-03-13 08:54:33 "},"cp-algorithms/子掩码枚举.html":{"url":"cp-algorithms/子掩码枚举.html","title":"子掩码枚举","keywords":"","body":"子掩码枚举 枚举给定掩码的所有子掩码 给定一个掩码 mmm，你想高效地迭代出它的所有子掩码，即只包含掩码 mmm 中二进制位为 111 的掩码 sss。 考虑此算法的实现，基于位操作的技巧： int s = m; while (s > 0) { // ... you can use s... s = (s - 1) & m; } 或者，使用更紧凑的语句 for： for (int s = m; s > 0; s = (s - 1) & m) { // ... you can use s... } 在上述两种代码中，将不处理等于 000 的子掩码。我们也可以在循环之外处理它，使用不太优雅的设计，例如： for (int s = m; ; s = (s - 1) & m) { // ... you can use s... if (s == 0) break; } 让我们来看看为什么上述代码遍历了掩码 mmm 的所有子掩码，没有重复，并且按下降顺序遍历。 假设我们当前为掩码 sss，并想遍历下一个掩码。通过将 sss 减去 111，我们将移除 sss 二进制位中最右边的 111，并且从该位往右都为 111。然后我们移除所有的不包含在掩码 mmm 中的不能成为其一部分的“额外的”值为 111 的位。为了实现这种移除，我们使用位运算 (s−1)&m(s - 1) \\& m(s−1)&m。最终，我们将掩码“剪掉” 111 来得到它所能得到的最大值，因此 sss 的下一个掩码是递减的。 因此，这个算法生成的掩码的所有子掩码是递减的，并且每个迭代只有两个为操作。 一个特例是 s=0s = 0s=0。在执行 s−1s - 1s−1 后，我们得到一个所有位都为 111 的掩码（-1），并且在执行 (s−1)&m(s - 1) \\& m(s−1)&m 后，我们的、得到的 sss 将等于 mmm。因此，当 s=0s = 0s=0 时需要小心，如果循环不能以 000 结束，这个算法将进入无限循环中。 遍历所有掩码的子掩码 O(3n)O(3^n)O(3​n​​) 在许多问题中，尤其是使用位掩码的动态规划中，你想迭代所有的位掩码，即每个掩码的的所有子掩码： for (int m = 0; m 0; (s - 1) & m) { // ... s and m ... } } powered by Gitbook该文件修订时间： 2021-03-13 13:57:36 "},"leetcode/":{"url":"leetcode/","title":"Leetcode","keywords":"","body":"Leetcode powered by Gitbook该文件修订时间： 2021-04-07 20:11:01 "},"leetcode/1820数组元素积的符号.html":{"url":"leetcode/1820数组元素积的符号.html","title":"1820. 数组元素积的符号","keywords":"","body":"5276. 数组元素积的符号 题目（简单） 已知函数 signFunc(x) 将会根据 x 的正负返回特定值： 如果 x 是正数，返回 1 。 如果 x 是负数，返回 -1 。 如果 x 是等于 0 ，返回 0 。 给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。 返回 signFunc(product) 。 示例 1： 输入：nums = [-1,-2,-3,-4,3,2,1] 输出：1 解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1 示例 2： 输入：nums = [1,5,0,2,-3] 输出：0 解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0 示例 3： 输入：nums = [-1,1,-1,1,-1] 输出：-1 解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1 提示： 1 -100 解题思路 暴力模拟即可。 可以转换为求数组 nums 中负数的个数是偶数还是奇数，偶数返回 1，奇数 -1。另外遍历过程中如果存在 0，则直接返回 0。 代码 class Solution { public int arraySign(int[] nums) { int ans = 1; for (int x : nums) { if (x == 0) return 0; ans *= x powered by Gitbook该文件修订时间： 2021-04-11 18:36:57 "},"leetcode/1821找出游戏的获胜者.html":{"url":"leetcode/1821找出游戏的获胜者.html","title":"1821. 找出游戏的获胜者","keywords":"","body":"5727. 找出游戏的获胜者 题目（中等） 共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。 游戏遵循如下规则： 从第 1 名小伙伴所在位置 开始 。 沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。 你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。 如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。 否则，圈子中最后一名小伙伴赢得游戏。 给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。 示例 1： 输入：n = 5, k = 2 输出：3 解释：游戏运行步骤如下： 1) 从小伙伴 1 开始。 2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。 3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。 4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。 5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。 6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。 7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。 8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。 9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。 示例 2： 输入：n = 6, k = 5 输出：1 解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。 提示： 1 解题思路 经典的约瑟夫环问题。 看题目给的数据范围可知，可以通过暴力模拟的方式解决。 方法一：暴力模拟 使用一个 List 维护 n 个小伙伴，当小伙伴数目大于 1，每次从中移除第 k 名小伙伴，由于 k 可以大于 小伙伴数n，故 移除小伙伴 id 为 (id + k - 1) % n，最后返回剩余的一个小伙伴。 方法二：数学——递推公式 约瑟夫环递推公式：f(n,k)=(f(n−1,k)+k)%n f(n, k) = (f(n - 1, k) + k) \\% nf(n,k)=(f(n−1,k)+k)%n 参考：https://blog.csdn.net/u011500062/article/details/72855826 代码 class Solution { public int findTheWinner(int n, int k) { List nums = new ArrayList<>(); for (int i = 0; i 1) { id = (id + k - 1) % n; nums.remove(id); n--; } return nums.get(0); } } class Solution { public int findTheWinner(int n, int k) { return f(n, k) + 1; } private int f(int n, int k) { if (n == 1) return 0; return (f(n - 1, k) + k) % n; } } class Solution { public int findTheWinner(int n, int k) { int ans = 0; for (int i = 2; i powered by Gitbook该文件修订时间： 2021-04-11 20:13:14 "},"leetcode/1822最少侧跳次数.html":{"url":"leetcode/1822最少侧跳次数.html","title":"1822. 最少侧跳次数","keywords":"","body":"5728. 最少侧跳次数 题目（中等） 给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。 给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。 比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。 这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。 比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。 这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。 注意：点 0 处和点 n 处的任一跑道都不会有障碍。 示例 1： 输入：obstacles = [0,1,2,3,0] 输出：2 解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。 注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。 示例 2： 输入：obstacles = [0,1,1,3,3,0] 输出：0 解释：跑道 2 没有任何障碍，所以不需要任何侧跳。 示例 3： 输入：obstacles = [0,2,1,0,3,0] 输出：2 解释：最优方案如上图所示。总共有 2 次侧跳。 提示： obstacles.length == n + 1 1 0 obstacles[0] == obstacles[n] == 0 解题思路 动态规划：先直跳，再侧跳 定义 dp[i][j] 表示当青蛙在点 i 处第 j 道这个位置时，最少的侧跳次数； 初始状态，在点 0 时，中间道是 0 ，上下为 1； 从点 1 开始遍历，每条道要优先于其前一个点同道，如果各自没有障碍物，侧跳次数不变； 然后再横向变化，可以从没有障碍物的其他道跳过来，侧跳数 + 1。 代码 class Solution { public int minSideJumps(int[] obstacles) { int n = obstacles.length; int[][] dp = new int[n][3]; dp[0][0] = 1; dp[0][1] = 0; dp[0][2] = 1; for (int i = 1; i powered by Gitbook该文件修订时间： 2021-04-11 19:54:43 "},"leetcode/1823求出 MK 平均值.html":{"url":"leetcode/1823求出 MK 平均值.html","title":"1823. 求出 MK 平均值","keywords":"","body":"5729. 求出 MK 平均值 题目 给你两个整数 m 和 k ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 MK 平均值 。 MK 平均值 按照如下步骤计算： 如果数据流中的整数少于 m 个，MK 平均值 为 -1 ，否则将数据流中最后 m 个元素拷贝到一个独立的容器中。 从这个容器中删除最小的 k 个数和最大的 k 个数。 计算剩余元素的平均值，并 向下取整到最近的整数 。 请你实现 MKAverage 类： MKAverage(int m, int k) 用一个空的数据流和两个整数 m 和 k 初始化 MKAverage 对象。 void addElement(int num) 往数据流中插入一个新的元素 num 。 int calculateMKAverage() 对当前的数据流计算并返回 MK 平均数 ，结果需 向下取整到最近的整数 。 示例 1： 输入： [\"MKAverage\", \"addElement\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"addElement\", \"addElement\", \"calculateMKAverage\"] [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []] 输出： [null, null, null, -1, null, 3, null, null, null, 5] 解释： MKAverage obj = new MKAverage(3, 1); obj.addElement(3); // 当前元素为 [3] obj.addElement(1); // 当前元素为 [3,1] obj.calculateMKAverage(); // 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素 obj.addElement(10); // 当前元素为 [3,1,10] obj.calculateMKAverage(); // 最后 3 个元素为 [3,1,10] // 删除最小以及最大的 1 个元素后，容器为 [3] // [3] 的平均值等于 3/1 = 3 ，故返回 3 obj.addElement(5); // 当前元素为 [3,1,10,5] obj.addElement(5); // 当前元素为 [3,1,10,5,5] obj.addElement(5); // 当前元素为 [3,1,10,5,5,5] obj.calculateMKAverage(); // 最后 3 个元素为 [5,5,5] // 删除最小以及最大的 1 个元素后，容器为 [5] // [5] 的平均值等于 5/1 = 5 ，故返回 5 提示： 3=m=105 3 3=m=10​5​​ 1=k∗2m 1 1=k∗2m 1=num=105 1 1=num=10​5​​ addElement 与 calculateMKAverage 总操作次数不超过 105 10^5 10​5​​ 次。 解题思路 方法一：暴力 题目给出操作次数不超过 105 10^5 10​5​​ 次，所以数据流中总元素数不会超过 105 10^5 10​5​​，因此我们可以使用一个长度为 105 10^5 10​5​​ 的数组 nums 保存数据流的所有元素。 addElement(int num) 直接在数组 nums 中添加元素 num。 calculateMKAverage() 如果数组 nums 长度小于 m，则返回 -1; 否则，取出 nums 最后 m 个数，对其进行排序，然后计算除了最小的 k 个数和最大的 k 个数的平均数。 注意：这里要使用数组，使用一个 m 长度的队列则会超时，使用数组能通过主要因为题目的用例不够，否则不应该能通过。 代码 class MKAverage { int[] nums; int m; int k; int len; public MKAverage(int m, int k) { this.nums = new int[100001]; this.m = m; this.k = k; this.len = 0; } public void addElement(int num) { nums[len++] = num; } public int calculateMKAverage() { if (len powered by Gitbook该文件修订时间： 2021-04-11 18:16:38 "},"leetcode/lcp-28采购方案.html":{"url":"leetcode/lcp-28采购方案.html","title":"LCP 28. 采购方案","keywords":"","body":"LCP 28.采购方案 题目 小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。 注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1 示例 1： 输入：nums = [2,5,3,5], target = 6 输出：1 解释：预算内仅能购买 nums[0] 与 nums[2]。 示例 2： 输入：nums = [2,2,1,9], target = 10 输出：4 解释：符合预算的采购方案如下： nums[0] + nums[1] = 4 nums[0] + nums[2] = 3 nums[1] + nums[2] = 3 nums[2] + nums[3] = 10 提示： 2 1 解题思路 为了求得购买的两个零件不超过预算的采购方案数，我们需要求出数组 nums 中的每个元素 i，使其满足nums[i] + nums[j] 的 j 的数量。计算数组中满足 nums[i] + nums[j] 的 j 的数量很像题目 两数之和。我们可以使用二分查找或者双指针的方法。 方法一：二分查找 对数组 nums 进行排序； 遍历 nums, 对于第 i 个元素： 二分查找 i 之前的元素中与其之和小于等于 target 的元素数目，即二分查找 [0, i) 中 target - nums[i] 的上界； 累加第 i 个元素满足预算的方案数； 返回总方案数 % 1000000007。 方法二：双指针 对数组 nums 进行排序； 初始化双指针 l = 0, r = nums.length - 1； 当 l 时： 如果 nums[i] + nums[j] > target，则 r--； 否则，(i,j] 范围内的元素与 l 处元素之和皆满足要求，即有j - i个方案，并将l++； 返回总方案数。 代码 class Solution { public int purchasePlans(int[] nums, int target) { final int MOD = 1000000007; Arrays.sort(nums); long ans = 0; for (int i = 0; i > 1); if (nums[mid] class Solution { public int purchasePlans(int[] nums, int target) { final int MOD = 1000000007; Arrays.sort(nums); int ans = 0, l = 0, r = nums.length - 1; while (l target) { r--; } else { ans += r - l; ans %= MOD; l++; } } return ans; } } powered by Gitbook该文件修订时间： 2021-04-07 20:46:54 "},"leetcode/lcp-29乐团站位.html":{"url":"leetcode/lcp-29乐团站位.html","title":"LCP 29. 乐团站位","keywords":"","body":"LCP 29.乐团站位 题目 某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。 为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，...，9 循环重复排列。例如当 num = 5 时，站位如图所示 请返回位于场地坐标 [Xpos,Ypos] 的成员所持乐器编号。 示例 1： 输入：num = 3, Xpos = 0, Ypos = 2 输出：3 解释： 示例 2： 输入：num = 4, Xpos = 1, Ypos = 2 输出：5 解释： 提示： 1 0 解题思路 数学题，找规律，求得从[0,0] 到 [Xpos,Ypos] 总的位置数量，然后对 9 取余。 代码 class Solution { public int orchestraLayout(int num, int xPos, int yPos) { int a = Math.min(xPos + 1, num - xPos); int b = Math.min(yPos + 1, num - yPos); long k = Math.min(a, b); // System.out.println(k); long sum = 4L * ((k - 1) * num - (k - 1) * (k - 1)); // System.out.println(sum); long x = k - 1, y = k - 1; long m = num - 2 * (k - 1); if (m == 1) { return answer(sum + 1); } if (isIn(xPos, yPos, k - 1, k - 1, k - 1, num - k - 1)) { sum += yPos - (k - 1) + 1; return answer(sum); } else { sum += m - 1; } if (isIn(xPos, yPos, k - 1, num - k, num - k - 1, num - k)) { sum += xPos - (k - 1) + 1; return answer(sum); } else { sum += m - 1; } if (isIn(xPos, yPos, num - k, k - 1 + 1, num - k, num - k)) { sum += (num - k - yPos) + 1; return answer(sum); } else { sum += m - 1; } if (isIn(xPos, yPos, k - 1 + 1, k - 1, num - k, k - 1)) { sum += (num - k - xPos) + 1; return answer(sum); } else { sum += m - 1; } return answer(sum); } private int answer(long sum) { // System.out.println(sum); return sum % 9 == 0 ? 9 : (int) (sum % 9); } private boolean isIn(long x, long y, long x1, long y1, long x2, long y2) { return x >= x1 && x = y1 && y powered by Gitbook该文件修订时间： 2021-04-07 20:53:48 "},"leetcode/lcp-30魔塔游戏.html":{"url":"leetcode/lcp-30魔塔游戏.html","title":"LCP 30. 魔塔游戏","keywords":"","body":"LCP 30.魔塔游戏 题目 小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。 小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。 示例 1： 输入：nums = [100,100,100,-250,-60,-140,-50,-50,100,150] 输出：1 解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求。 示例 2： 输入：nums = [-200,-300,400,0] 输出：-1 解释：调整访问顺序也无法完成全部房间的访问。 提示： 1 -10^5 解题思路 贪心思想。 遍历数组 nums，使用优先级队列保存怪物（负数），每当血量 时，从队列中弹出造成伤害最大的怪物，将其移到数组末尾，这时需要将这部分血量加上，最后在遍历完数组时，判断剩余血量加上移至末尾的怪物造成的伤害是否大于0，不大于0则返回-1，否则返回队列弹出次数。 代码 class Solution { public int magicTower(int[] nums) { long sum = 1, ans = 0, tmp = 0; PriorityQueue queue = new PriorityQueue<>(); for (int i = 0; i = 0) { sum += nums[i]; } else { sum += nums[i]; queue.offer((long) nums[i]); while (sum powered by Gitbook该文件修订时间： 2021-04-07 21:03:49 "},"leetcode/lcp-31变换的迷宫.html":{"url":"leetcode/lcp-31变换的迷宫.html","title":"LCP 31. 变换的迷宫","keywords":"","body":"LCP 31.变换的迷宫 题目 某解密游戏中，有一个 N*M 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 (n-1,m-1) 位置。迷宫变化规律记录于 maze 中，maze[i] 表示 i 时刻迷宫的地形状态，\".\" 表示可通行空地，\"#\" 表示陷阱。 地形图初始状态记作 maze[0]，此时小力位于起点 (0,0)。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。 小力背包有以下两个魔法卷轴（卷轴使用一次后消失）： 临时消除术：将指定位置在下一个时刻变为空地； 永久消除术：将指定位置永久变为空地。 请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？ 注意： 输入数据保证起点和终点在所有时刻均为空地。 示例 1： 输入：maze = [[\".#.\",\"#..\"],[\"...\",\".#.\"],[\".##\",\".#.\"],[\"..#\",\".#.\"]] 输出：true 解释： 示例 2： 输入：maze = [[\".#.\",\"...\"],[\"...\",\"...\"]] 输出：false 解释：由于时间不够，小力无法到达终点逃出迷宫。 示例 3： 输入：maze = [[\"...\",\"...\",\"...\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"]] 输出：false 解释：由于道路不通，小力无法到达终点逃出迷宫。 提示： 1 1 maze[i][j] 仅包含 \".\"、\"#\" 解题思路 深度优先遍历。 代码 class Solution { public boolean escapeMaze(List> maze) { int t = maze.size(), m = maze.get(0).size(), n = maze.get(0).get(0).length(); boolean[][][][][] vis = new boolean[t][m][n][2][2]; return dfs(0, 0, maze, 1, 1, 0, -1, -1, vis); } private boolean dfs(int x, int y, List> maze, int p, int q, int t, int qx, int qy, boolean[][][][][] vis) { int m = maze.get(0).size(), n = maze.get(0).get(0).length(); if (x == m - 1 && y == n - 1) { return true; } if (t == maze.size() - 1) { return false; } if (vis[t][x][y][p][q]) return false; vis[t][x][y][p][q] = true; int[] dx = {0, 0, 1, -1, 0}; int[] dy = {1, -1, 0, 0, 0}; for (int i = 0; i = m || ny = n) continue; if (maze.get(t + 1).get(nx).charAt(ny) == '.') { if (dfs(nx, ny, maze, p, q, t + 1, qx, qy, vis)) return true; continue; } if (q == 0 && nx == qx && ny == qy) { if (dfs(nx, ny, maze, p, 0, t + 1, qx, qy, vis)) return true; } else { if (p == 1 && dfs(nx, ny, maze, 0, q, t + 1, qx, qy, vis)) { return true; } if (q == 1 && dfs(nx, ny, maze, p, 0, t + 1, nx, ny, vis)) { return true; } } } return false; } } powered by Gitbook该文件修订时间： 2021-04-07 21:07:07 "},"leetcode/weekly-contest/":{"url":"leetcode/weekly-contest/","title":"周赛","keywords":"","body":"周赛 powered by Gitbook该文件修订时间： 2021-04-11 20:00:44 "},"leetcode/weekly-contest/第236场.html":{"url":"leetcode/weekly-contest/第236场.html","title":"第236场","keywords":"","body":"第236场 1. 数组元素积的符号 2. 找出游戏的获胜者 3. 最少侧跳次数 4. 求出 MK 平均值 powered by Gitbook该文件修订时间： 2021-04-11 20:07:09 "}}